// This file is automatically generated.
// Do not modify this file manually.


#ifdef SWIGCHICKEN
%module itkSymmetricSecondRankTensorChicken
#endif
#ifdef SWIGCSHARP
%module itkSymmetricSecondRankTensorCsharp
#endif
#ifdef SWIGGUILE
%module itkSymmetricSecondRankTensorGuile
#endif
#ifdef SWIGJAVA
%module itkSymmetricSecondRankTensorJava
#endif
#ifdef SWIGLUA
%module itkSymmetricSecondRankTensorLua
#endif
#ifdef SWIGMODULA3
%module itkSymmetricSecondRankTensorModula3
#endif
#ifdef SWIGMZSCHEME
%module itkSymmetricSecondRankTensorMzscheme
#endif
#ifdef SWIGOCAML
%module itkSymmetricSecondRankTensorOcaml
#endif
#ifdef SWIGPERL
%module itkSymmetricSecondRankTensorPerl
#endif
#ifdef SWIGPERL5
%module itkSymmetricSecondRankTensorPerl5
#endif
#ifdef SWIGPHP
%module itkSymmetricSecondRankTensorPhp
#endif
#ifdef SWIGPHP4
%module itkSymmetricSecondRankTensorPhp4
#endif
#ifdef SWIGPHP5
%module itkSymmetricSecondRankTensorPhp5
#endif
#ifdef SWIGPIKE
%module itkSymmetricSecondRankTensorPike
#endif
#ifdef SWIGPYTHON
%module itkSymmetricSecondRankTensorPython
#endif
#ifdef SWIGR
%module itkSymmetricSecondRankTensorR
#endif
#ifdef SWIGRUBY
%module itkSymmetricSecondRankTensorRuby
#endif
#ifdef SWIGSEXP
%module itkSymmetricSecondRankTensorSexp
#endif
#ifdef SWIGTCL
%module itkSymmetricSecondRankTensorTcl
#endif
#ifdef SWIGXML
%module itkSymmetricSecondRankTensorXml
#endif

%{
#include "VXLNumerics.includes"
#include "Base.includes"
%}


%{
%}




%import wrap_itkFixedArray.i
%import wrap_itkMatrix.i


%include itk.i
%include wrap_itkSymmetricSecondRankTensor_ext.i


 class itkSymmetricSecondRankTensorD2 : public itkFixedArrayD3 {
   public:
     enum  {  Dimension = 2 };
     enum  {  InternalDimension = 3 };
     ~itkSymmetricSecondRankTensorD2();
     itkSymmetricSecondRankTensorD2 & operator=(itkSymmetricSecondRankTensorD2 const & arg0);
     itkSymmetricSecondRankTensorD2(itkSymmetricSecondRankTensorD2 const & arg0);
     itkSymmetricSecondRankTensorD2();
     itkSymmetricSecondRankTensorD2(double const & r);
     itkSymmetricSecondRankTensorD2(double const * r);
     itkSymmetricSecondRankTensorD2 & operator=(double const & r);
     itkSymmetricSecondRankTensorD2 & operator=(double const * r);
     itkSymmetricSecondRankTensorD2 operator+(itkSymmetricSecondRankTensorD2 const & vec) const;
     itkSymmetricSecondRankTensorD2 operator-(itkSymmetricSecondRankTensorD2 const & vec) const;
     itkSymmetricSecondRankTensorD2 const & operator+=(itkSymmetricSecondRankTensorD2 const & vec);
     itkSymmetricSecondRankTensorD2 const & operator-=(itkSymmetricSecondRankTensorD2 const & vec);
     itkSymmetricSecondRankTensorD2 operator*(double const & scalar) const;
     itkSymmetricSecondRankTensorD2 operator/(double const & scalar) const;
     itkSymmetricSecondRankTensorD2 const & operator*=(double const & scalar);
     itkSymmetricSecondRankTensorD2 const & operator/=(double const & scalar);
     static unsigned int GetNumberOfComponents();
     double GetNthComponent(int c) const;
     void SetNthComponent(int c, double const & v);
     double & operator()(unsigned int row, unsigned int col);
     double const & operator()(unsigned int row, unsigned int col) const;
     void SetIdentity();
     double GetTrace() const;
     void ComputeEigenValues(itkFixedArrayD2 & eigenValues) const;
     void ComputeEigenAnalysis(itkFixedArrayD2 & eigenValues, itkMatrixD22 & eigenVectors) const;
     itkSymmetricSecondRankTensorD2 PreMultiply(itkMatrixD22 const & m) const;
     itkSymmetricSecondRankTensorD2 PostMultiply(itkMatrixD22 const & m) const;
   private:
   protected:
 };


 class itkSymmetricSecondRankTensorD3 : public itkFixedArrayD6 {
   public:
     enum  {  Dimension = 3 };
     enum  {  InternalDimension = 6 };
     ~itkSymmetricSecondRankTensorD3();
     itkSymmetricSecondRankTensorD3 & operator=(itkSymmetricSecondRankTensorD3 const & arg0);
     itkSymmetricSecondRankTensorD3(itkSymmetricSecondRankTensorD3 const & arg0);
     itkSymmetricSecondRankTensorD3();
     itkSymmetricSecondRankTensorD3(double const & r);
     itkSymmetricSecondRankTensorD3(double const * r);
     itkSymmetricSecondRankTensorD3 & operator=(double const & r);
     itkSymmetricSecondRankTensorD3 & operator=(double const * r);
     itkSymmetricSecondRankTensorD3 operator+(itkSymmetricSecondRankTensorD3 const & vec) const;
     itkSymmetricSecondRankTensorD3 operator-(itkSymmetricSecondRankTensorD3 const & vec) const;
     itkSymmetricSecondRankTensorD3 const & operator+=(itkSymmetricSecondRankTensorD3 const & vec);
     itkSymmetricSecondRankTensorD3 const & operator-=(itkSymmetricSecondRankTensorD3 const & vec);
     itkSymmetricSecondRankTensorD3 operator*(double const & scalar) const;
     itkSymmetricSecondRankTensorD3 operator/(double const & scalar) const;
     itkSymmetricSecondRankTensorD3 const & operator*=(double const & scalar);
     itkSymmetricSecondRankTensorD3 const & operator/=(double const & scalar);
     static unsigned int GetNumberOfComponents();
     double GetNthComponent(int c) const;
     void SetNthComponent(int c, double const & v);
     double & operator()(unsigned int row, unsigned int col);
     double const & operator()(unsigned int row, unsigned int col) const;
     void SetIdentity();
     double GetTrace() const;
     void ComputeEigenValues(itkFixedArrayD3 & eigenValues) const;
     void ComputeEigenAnalysis(itkFixedArrayD3 & eigenValues, itkMatrixD33 & eigenVectors) const;
     itkSymmetricSecondRankTensorD3 PreMultiply(itkMatrixD33 const & m) const;
     itkSymmetricSecondRankTensorD3 PostMultiply(itkMatrixD33 const & m) const;
   private:
   protected:
 };


 class itkSymmetricSecondRankTensorF2 : public itkFixedArrayF3 {
   public:
     enum  {  Dimension = 2 };
     enum  {  InternalDimension = 3 };
     ~itkSymmetricSecondRankTensorF2();
     itkSymmetricSecondRankTensorF2 & operator=(itkSymmetricSecondRankTensorF2 const & arg0);
     itkSymmetricSecondRankTensorF2(itkSymmetricSecondRankTensorF2 const & arg0);
     itkSymmetricSecondRankTensorF2();
     itkSymmetricSecondRankTensorF2(float const & r);
     itkSymmetricSecondRankTensorF2(float const * r);
     itkSymmetricSecondRankTensorF2 & operator=(float const & r);
     itkSymmetricSecondRankTensorF2 & operator=(float const * r);
     itkSymmetricSecondRankTensorF2 operator+(itkSymmetricSecondRankTensorF2 const & vec) const;
     itkSymmetricSecondRankTensorF2 operator-(itkSymmetricSecondRankTensorF2 const & vec) const;
     itkSymmetricSecondRankTensorF2 const & operator+=(itkSymmetricSecondRankTensorF2 const & vec);
     itkSymmetricSecondRankTensorF2 const & operator-=(itkSymmetricSecondRankTensorF2 const & vec);
     itkSymmetricSecondRankTensorF2 operator*(double const & scalar) const;
     itkSymmetricSecondRankTensorF2 operator/(double const & scalar) const;
     itkSymmetricSecondRankTensorF2 const & operator*=(double const & scalar);
     itkSymmetricSecondRankTensorF2 const & operator/=(double const & scalar);
     static unsigned int GetNumberOfComponents();
     float GetNthComponent(int c) const;
     void SetNthComponent(int c, float const & v);
     float & operator()(unsigned int row, unsigned int col);
     float const & operator()(unsigned int row, unsigned int col) const;
     void SetIdentity();
     double GetTrace() const;
     void ComputeEigenValues(itkFixedArrayF2 & eigenValues) const;
     void ComputeEigenAnalysis(itkFixedArrayF2 & eigenValues, itkMatrixF22 & eigenVectors) const;
     itkSymmetricSecondRankTensorF2 PreMultiply(itkMatrixF22 const & m) const;
     itkSymmetricSecondRankTensorF2 PostMultiply(itkMatrixF22 const & m) const;
   private:
   protected:
 };


 class itkSymmetricSecondRankTensorF3 : public itkFixedArrayF6 {
   public:
     enum  {  Dimension = 3 };
     enum  {  InternalDimension = 6 };
     ~itkSymmetricSecondRankTensorF3();
     itkSymmetricSecondRankTensorF3 & operator=(itkSymmetricSecondRankTensorF3 const & arg0);
     itkSymmetricSecondRankTensorF3(itkSymmetricSecondRankTensorF3 const & arg0);
     itkSymmetricSecondRankTensorF3();
     itkSymmetricSecondRankTensorF3(float const & r);
     itkSymmetricSecondRankTensorF3(float const * r);
     itkSymmetricSecondRankTensorF3 & operator=(float const & r);
     itkSymmetricSecondRankTensorF3 & operator=(float const * r);
     itkSymmetricSecondRankTensorF3 operator+(itkSymmetricSecondRankTensorF3 const & vec) const;
     itkSymmetricSecondRankTensorF3 operator-(itkSymmetricSecondRankTensorF3 const & vec) const;
     itkSymmetricSecondRankTensorF3 const & operator+=(itkSymmetricSecondRankTensorF3 const & vec);
     itkSymmetricSecondRankTensorF3 const & operator-=(itkSymmetricSecondRankTensorF3 const & vec);
     itkSymmetricSecondRankTensorF3 operator*(double const & scalar) const;
     itkSymmetricSecondRankTensorF3 operator/(double const & scalar) const;
     itkSymmetricSecondRankTensorF3 const & operator*=(double const & scalar);
     itkSymmetricSecondRankTensorF3 const & operator/=(double const & scalar);
     static unsigned int GetNumberOfComponents();
     float GetNthComponent(int c) const;
     void SetNthComponent(int c, float const & v);
     float & operator()(unsigned int row, unsigned int col);
     float const & operator()(unsigned int row, unsigned int col) const;
     void SetIdentity();
     double GetTrace() const;
     void ComputeEigenValues(itkFixedArrayF3 & eigenValues) const;
     void ComputeEigenAnalysis(itkFixedArrayF3 & eigenValues, itkMatrixF33 & eigenVectors) const;
     itkSymmetricSecondRankTensorF3 PreMultiply(itkMatrixF33 const & m) const;
     itkSymmetricSecondRankTensorF3 PostMultiply(itkMatrixF33 const & m) const;
   private:
   protected:
 };


