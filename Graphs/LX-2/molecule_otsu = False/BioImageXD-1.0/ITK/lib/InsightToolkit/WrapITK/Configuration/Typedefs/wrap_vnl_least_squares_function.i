// This file is automatically generated.
// Do not modify this file manually.


#ifdef SWIGCHICKEN
%module vnl_least_squares_functionChicken
#endif
#ifdef SWIGCSHARP
%module vnl_least_squares_functionCsharp
#endif
#ifdef SWIGGUILE
%module vnl_least_squares_functionGuile
#endif
#ifdef SWIGJAVA
%module vnl_least_squares_functionJava
#endif
#ifdef SWIGLUA
%module vnl_least_squares_functionLua
#endif
#ifdef SWIGMODULA3
%module vnl_least_squares_functionModula3
#endif
#ifdef SWIGMZSCHEME
%module vnl_least_squares_functionMzscheme
#endif
#ifdef SWIGOCAML
%module vnl_least_squares_functionOcaml
#endif
#ifdef SWIGPERL
%module vnl_least_squares_functionPerl
#endif
#ifdef SWIGPERL5
%module vnl_least_squares_functionPerl5
#endif
#ifdef SWIGPHP
%module vnl_least_squares_functionPhp
#endif
#ifdef SWIGPHP4
%module vnl_least_squares_functionPhp4
#endif
#ifdef SWIGPHP5
%module vnl_least_squares_functionPhp5
#endif
#ifdef SWIGPIKE
%module vnl_least_squares_functionPike
#endif
#ifdef SWIGPYTHON
%module vnl_least_squares_functionPython
#endif
#ifdef SWIGR
%module vnl_least_squares_functionR
#endif
#ifdef SWIGRUBY
%module vnl_least_squares_functionRuby
#endif
#ifdef SWIGSEXP
%module vnl_least_squares_functionSexp
#endif
#ifdef SWIGTCL
%module vnl_least_squares_functionTcl
#endif
#ifdef SWIGXML
%module vnl_least_squares_functionXml
#endif

%{
#include "VXLNumerics.includes"
%}


%{
%}




%import wrap_vnl_vector.i
%import wrap_vnl_matrix.i


%include itk.i
%include wrap_vnl_least_squares_function_ext.i


 class vnl_least_squares_function {
   public:
     enum UseGradient {  no_gradient = 0,  use_gradient = 1 };
     vnl_least_squares_function & operator=(vnl_least_squares_function const & arg0);
     vnl_least_squares_function(vnl_least_squares_function const & arg0);
     vnl_least_squares_function(unsigned int number_of_unknowns, unsigned int number_of_residuals, vnl_least_squares_function::UseGradient g = ::vnl_least_squares_function::use_gradient);
     ~vnl_least_squares_function();
     void throw_failure();
     void clear_failure();
     virtual void f(vnl_vectorD const & x, vnl_vectorD & fx) = 0;
     virtual void gradf(vnl_vectorD const & x, vnl_matrixD & jacobian);
     void fdgradf(vnl_vectorD const & x, vnl_matrixD & jacobian, double stepsize);
     virtual void trace(int iteration, vnl_vectorD const & x, vnl_vectorD const & fx);
     double rms(vnl_vectorD const & x);
     unsigned int get_number_of_unknowns() const;
     unsigned int get_number_of_residuals() const;
     bool has_gradient() const;
   private:
     void dim_warning(unsigned int n_unknowns, unsigned int n_residuals);
   protected:
     void init(unsigned int number_of_unknowns, unsigned int number_of_residuals);
 };


